

It's okay.

There is a time in your life where you don't understand Python, and there is a time in your life where you do.

And there is nothing in between. All you have to do is take a leap of faith.

## 3. Stop Watching

And that begs the question: how do I become a good problem solver? The answer is to go solve a bunch of problems. Turn off YouTube and go write some code. Will you ever learn to play guitar by watching other people on YouTube play guitar? The answer is no. You also need to be playing the guitar along with them. Books and tutorials are great. Sign up for Fireship Pro, but they're utterly useless if you're not coding along with them. In my tutorials, I try to set you up with something cool to build so you can go have fun and fail on your own. You can build things based on tutorials, you can try to build your own stuff, you can do coding challenges, participate in hackathons, and all kinds of other stuff. If you're serious, you should be coding at least a couple of hours every day. There's a reason they require pilots to have a certain number of flying hours. Experience matters more than anything else. And luckily for you, to get time in the saddle, all you have to do is sit on your ass in front of your computer screen and hit the keyboard until something cool happens.

## 4. Stay Healthy

Speaking of which, sitting on your ass in front of a computer screen is not natural or healthy. And that means you need to work extra hard in this line of work to protect your health, both mentally and physically. That's why I prefer to eat at Arby's, the most trusted name in nutrition. I also get plenty of sunshine and exercise to offset the time I spend banging my head against the keyboard in my mom's dark, windowless basement. If your health is not optimal, you won't learn as efficiently. And there's no activity in the world that's worth sacrificing your health over.

## 5. Feynman Technique

Now, let's switch gears and talk about a physicist named Richard Feynman. He's a Nobel Prize winner known for many things, one of which is his learning technique. It goes like this: choose a concept you want to learn about, explain it to a 12-year-old, reflect, refine, simplify, then organize and review. In other words, you learn most efficiently when you try to teach the very thing you're learning. I can tell you right now that I've learned way more about programming from running this YouTube channel than I ever did working all by myself. Now, that doesn't mean that everybody needs to go and start a YouTube channel. All you have to do is pretend to teach something. But if you can create valuable content out of it, like a video or blog post, that's even better. Or if you already have a job, you'll find that you learn a lot just by mentoring other people. Or if you don't have a job, you can join programming Slack or Discord channels and help people out there or answer questions on Stack Overflow. Helping others feels good, and it forces you to be extremely precise about what you actually know. Here's how it might look for a programmer: choose a topic, like "I want to program a video game." Do some research and experimenting, and write a summary explaining the technology to a 12-year-old. Then go and build something and get to a full working demo as quickly as possible. It doesn't need to be perfect, because in the final step, you'll go back and refactor and simplify and find ways to improve your process and get feedback from someone more experienced than you, if possible. So approach it like a teacher, even though you have no idea what you're currently teaching.

## 6. Dopamine Hits

Now, I said something very subtle but very important, and that is to build a full working demo as quickly as possible. Learning is supposed to be painful, but there also needs to be some kind of reward for that pain. And the more quickly you can get to those rewards, the better, because what you want is a positive feedback loop that basically makes you addicted to coding. There are ways we can hack the most primitive parts of our brain. What I do almost every day before I go to bed is write down a few small goals that I want to achieve the next day. The important thing is that the goals are achievable, because then writing a check mark next to that goal feels good. When good things happen, your brain releases dopamine, and you want to try to find activities that, after hard work, give you that dopamine hit. Because otherwise, you'll have a negative feedback loop, in which case you're going to absolutely hate coding in no time. That'd be like learning how to press the strings on a guitar without ever knowing how to play an actual song. The idea is to work hard and be rewarded, but you don't want to work too hard.

## 7. Not Too Hard, Though

It's extremely important, especially for programming, to pace yourself and take regular breaks. For most people, that likely means one or two hours of programming followed by a nice long break. I remember in my early days being absolutely determined to not let the error messages win. I'd go late into the night, Stack Overflowing every possible combination of questions, only to give up and get a good night's sleep and then come back and immediately solve the problem in the morning. And this isn't unique to me; it happens to everybody because mental spacing is actually a very important thing. You can be mentally exhausted while at the same time your ego is saying, "You got this, bro. Don't be a loser." But the reality is that the most efficient thing to do is go outside, get some sunshine, jump in a cold body of water, and get some sleep. When you wake up, you'll be ready to crush it once again.

## 8. Learn Like a Pro

Now that you know how to learn to code, all you have to do is go to Google, type in what you want to learn, and let it be your guide, because that's basically all you ever do as a software engineer. I'm going to go ahead and wrap things up there. Make sure to hit the subscribe button to get the next video in this installment about mastering the technical interview. Thanks for watching, and I will see you in the next one.